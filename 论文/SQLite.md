# 摘要

在其首次发布后的二十年里，SQLite 已成为目前应用最广泛的数据库引擎。如今，几乎在每一部智能手机、计算机、网络浏览器、电视和汽车中都能找到 SQLite。它的普及可能归因于几个因素，包括其进程内设计、独立的代码库、广泛的测试套件以及跨平台的文件格式。虽然 SQLite 支持复杂的分析查询，但它主要是为快速在线事务处理（OLTP）而设计的，采用面向行的执行方式和 B 树存储格式。然而，在边缘计算和数据科学兴起的推动下，对高效的进程内在线分析处理（OLAP）的需求日益增长。名为“分析领域的 SQLite”的数据库引擎 DuckDB 最近应运而生以满足这一需求。虽然 DuckDB 在 OLAP 基准测试中表现出色，但尚不清楚 SQLite 与之相比如何。此外，我们尚未发现有任何研究试图找出 SQLite 在 OLAP 工作负载上性能表现的根本原因。在本文中，我们在这种不断变化的工作负载环境背景下讨论 SQLite。我们描述了 SQLite 如何从最初的简陋状态发展成为如今功能齐全的数据库引擎。我们在三个基准测试上评估现代 SQLite 的性能，每个基准测试代表了进程内数据管理的不同类型，包括事务处理、分析处理和二进制大对象（blob）处理。我们深入研究 SQLite 上的分析数据处理，确定关键瓶颈并权衡潜在的解决方案。由于我们的优化，SQLite 在 [Star Schema Benchmark](https://github.com/zingdle/SSB-sqlite) 上现在速度提升高达 4.2 倍。最后，我们讨论 SQLite 的未来，展望它将如何发展以满足新的需求和挑战。

# 引言

SQLite 最初于 2000 年 8 月作为一个小型数据管理函数库发布。它最初作为 Tcl 编程语言的扩展进行打包，SQLite 的诞生源于调试在单独进程中运行的数据库服务器时的挫败感。与客户端—服务器数据库系统不同，客户端—服务器数据库系统通常占用专用进程并通过共享内存原语与应用程序通信，而 SQLite 嵌入在宿主应用程序的进程中。应用程序通过调用 SQLite 库函数来管理 SQLite 数据库，而不是跨进程边界与数据库服务器通信。

在其首次发布后的几十年里，SQLite 逐渐发展成为现存部署最广泛的数据库引擎[27]。SQLite 被嵌入到主流的网络浏览器、个人电脑、智能电视、汽车媒体系统以及 PHP 和 Python 编程语言中。此外，在每一台 iOS 和安卓设备中都能找到 SQLite，目前这些设备的数量已达数十亿。可能有超过一万亿个 SQLite 数据库正在被积极使用。据估计，SQLite 是各类软件库中部署最广泛的之一。

SQLite 的流行不太可能归因于单一因素。相反，除了其从根本上可嵌入的设计之外，还有几个特点共同作用，使得 SQLite 在广泛的场景中都很有用。特别是，SQLite 努力做到：

- 跨平台。一个 SQLite 数据库存储在单个文件中，该文件可以在 32 位和 64 位机器以及小端和大端架构之间自由复制[30]。SQLite 可以在任何具有 8 位字节、二进制补码 32 位和 64 位整数以及 C 编译器的平台上运行。由于其稳定性和可移植性，SQLite 的文件格式是美国国会图书馆推荐的用于保存数字内容的存储格式[1]。
- 紧凑且自包含。SQLite 库以单个 C 文件的形式提供，大约由 15 万行源代码组成[31]。启用所有功能后，编译后的库大小可以小于 750 KiB[17]。SQLite 没有外部依赖项，只需要几个 C 标准库函数即可运行。SQLite 无需安装或配置。
- 可靠。SQLite 的每一行代码都有超过 600 行的测试代码[25]。测试覆盖了库中 100%的分支。测试套件极其多样化，包括模糊测试、边界值测试、回归测试以及模拟操作系统崩溃、电源故障、I/O 错误和内存不足错误的测试。由于其可靠性，SQLite 在关键任务应用中，如飞行软件中经常被使用[36]。
- 快速。SQLite 可以支持每秒数万笔交易。在某些情况下，SQLite 读取和写入二进制大对象数据的速度比文件系统快 35%，并且使用的存储空间少 20%[16]。SQLite 的查询规划器为复杂的分析查询生成高效的计划[28]。

虽然在许多方面都不同，但 SQLite 与为在线事务处理（OLTP）设计的传统数据库系统有几个共同特征。SQLite 采用面向行的存储格式，其中给定记录的所有列都存储在连续的内存区域中[23]。SQLite 的运算符作用于单个行，而不是像向量化查询执行那样作用于一批行[32]。最后，SQLite 提供完整的 ACID 保证：事务是原子性、一致性、隔离性和持久性的[34]。

然而，SQLite 被用于远远超出传统联机事务处理（OLTP）边界的场景。SQLite 的著名用途包括在嵌入式设备和物联网上处理数据、作为应用程序文件格式管理应用程序状态、服务网站请求、分析大型数据集、缓存企业数据以及在不同系统之间传输数据[19]。先前一项追踪手机上 SQLite 活动的研究发现，SQLite 被用于各种各样的任务[39]。在该研究期间，SQLite 执行的大多数操作是单表扫描和键值查找。然而，跟踪记录中还包括更复杂的分析查询，涉及多个表之间的连接。此外，一小部分但很重要的工作负载由联机事务处理（OLTP）操作组成。

最近，边缘计算和交互式数据分析的爆炸式增长引发了对高效进程内在线分析处理（OLAP）的需求。已经创建或调整了几个用于 OLAP 的数据库系统，包括 MonetDB [37]、Oracle OLAP [10] 和 SAP HANA [11]。然而，这些努力在很大程度上集中在客户端-服务器架构上。尽管如此，在客户端-服务器数据库系统难以使用甚至无法使用的情况下，通常需要高效的 OLAP。

“在进程内联机分析处理（In-process OLAP）是边缘计算的一个重要组成部分。在物联网中，数据分析越来越多地被推向边缘，以减少网络流量和服务器负载[48]。此外，在网络上发送敏感数据通常会涉及隐私问题。虽然联机分析处理数据库系统非常适合数据分析任务，但边缘设备可能不具备承载客户端-服务器数据库系统所需的能量或计算资源。”

作为另一个例子，数据科学家在构建模型之前经常进行进程内联机分析处理（OLAP），以交互方式探索数据集。数据科学工作流程的很大一部分涉及关系代数运算，例如选择、投影、连接和聚合。这些操作可以使用诸如 pandas[52] 这样的数据框库简洁地编写脚本。然而，尽管数据框库易于使用，但它们提供的查询优化有限，并且经常会具体化大型中间结果。此外，数据集通常超出内存容量，这可能迫使数据科学家实现手动滚动的缓冲区管理，并使用低效的存储表示形式，如 CSV 或 JSON。一个可嵌入的数据库引擎更适合处理这些工作负载。为此原因是，SQLite 已经是数据科学中一种流行的工具。由于其稳定性、可移植性和空间效率，SQLite 数据库文件格式通常用于共享数据集。例如，SQLite 是流行的 Kaggle 数据科学平台使用的主要文件格式之一[38]。Python 的 sqlite3 模块[15]经常用于在数据科学笔记本中执行 SQL 操作。虽然 SQLite 生成高效的查询计划并能处理比内存大得多的数据集，但与上述专门用于联机分析处理（OLAP）的数据库系统相比，它在分析方面的优化较少。

这些领域是强大的、可嵌入式联机分析处理（OLAP）数据库引擎的主要目标。DuckDB [47] 最近应运而生以满足这一需求。它被昵称为“用于分析的 SQLite”，DuckDB 从头开始构建，用于进程内 OLAP，采用列存储、并行和矢量化查询处理以及针对提取-转换-加载（ETL）操作进行优化的多版本并发控制。虽然仍处于预发布开发阶段，但 DuckDB 已经在 OLAP 基准测试中产生了具有竞争力的性能 [8]。我们相信，DuckDB 在可嵌入式数据处理方面填补了一个急需的空白。

虽然 SQLite 和 DuckDB 都分别经过了评估，但文献中缺少对这两个系统的全面比较。如上文所述，SQLite 与联机事务处理（OLTP）数据库系统有许多共同的设计元素，因此人们可能期望它在 OLTP 基准测试中表现出色。然而，SQLite 的目标是尽可能通用，因此可以合理地预期它在各种工作负载下都具有有竞争力的性能。相比之下，DuckDB 是专门为分析而构建的，因此人们可能期望它在联机分析处理（OLAP）基准测试中优于 SQLite。

在本文中，我们为这些预期提供了实验支持并量化了其程度。对于联机分析处理（OLAP），我们更深入了一步——我们确定了 SQLite 负责其 OLAP 性能的特定特征，然后提出了可大幅提高其速度的优化方案。

这篇论文的主要贡献是：

我们呈现了 SQLite 的历史视角。我们还给出了其架构的简洁描述。我们以 DuckDB 为基线，对 SQLite 在典型工作负载下进行了全面评估。我们的评估包括代表不同类型的进程内数据管理的基准测试。我们针对分析型数据处理对 SQLite 进行了优化。我们确定了 SQLite 中的关键瓶颈，并讨论了潜在解决方案的优缺点。我们将优化整合到 SQLite 中，使 SSB 的整体速度提高了 4.2 倍。

我们确定了几个特定于可嵌入数据库引擎的性能指标，包括库占用空间和二进制大对象处理性能。我们对 SQLite 未来进一步提高性能的潜在方向进行了高层次描述。

本文的其余部分组织如下。第 2 节提供了 SQLite 的架构概述及其设计原理。第 3 节在不断变化的工作负载和硬件背景下讨论 SQLite。第 4 节在各种情况下对 SQLite 和 DuckDB 进行性能指标评估，并介绍我们的优化措施。第 5 节讨论未来的方向，第 6 节进行总结。

# 架构

在本节中，我们简要介绍 SQLite 的架构。我们提供这些信息是为了便于理解后续章节，并使本文内容完整。有关 SQLite 架构的更详细信息可以在文档[20]中找到。我们还讨论了 SQLite 设计核心元素背后的一些基本原理。

## 模块

SQLite 遵循模块化设计。它的架构由图 1 中所示的四组模块组成。核心模块负责接收和执行 SQL 语句。SQL 编译器模块将 SQL 语句转换为可由虚拟机执行的字节码程序。后端模块便于访问数据库页面，并与操作系统交互以持久化数据。SQLite 还包括几个辅助模块，包括大量的测试套件以及用于内存分配、字符串操作和随机数生成的实用程序。我们将在下面更详细地描述其中一些模块。

2.1.1 SQL 编译器模块。从概念上讲，每个 SQL 语句都可以被视为一个可执行程序。进一步扩展这个类比，SQLite 的词法分析器、解析器和代码生成器就像一个编译器，将 SQL 翻译成可执行代码。代码生成器的输出是一个字节码程序。一个字节码示例。

![](079298231afa2ba6eed02d33c2c4c1c6.clipboard-2024-12-23.webp)

程序由星型模式基准测试（SSB）Q1.1 编译而来，如表格 1 所示。字节码程序由一个或多个虚拟指令组成。每个虚拟指令包括一个唯一的操作码和几个操作数。这些虚拟指令是 SQLite 中数据处理的基本构建块。虽然它们可以组合成复杂的程序，但指令本身是相当低级的。例如，Column 指令从当前行中提取第 P2 列并将其存储在寄存器 P3 中。如果寄存器 P3 中的值小于寄存器 P1 中的值，Lt 指令将跳转到地址 P2。SQLite 的虚拟指令集的完整描述可在文档[32]中找到。

2.1.2 核心模块。SQLite 的执行引擎结构为虚拟机。该虚拟机，也称为虚拟数据库引擎（VDBE），是 SQLite 的核心。VDBE 负责执行由代码生成器生成的字节码程序的逻辑。VDBE 从地址 0 的指令开始，一直执行到看到停止指令、遇到错误或到达字节码程序末尾。指令逻辑在 VDBE 中实现为一个大型的 switch 语句，其中每个指令都作为一个独特的情况进行处理。当 VDBE 退出时，它会释放可能已分配的任何内存，并关闭可能已打开的任何游标。如果遇到错误，VDBE 将回滚对数据库的任何未决更改，以使其处于干净状态。

2.1.3 后端模块。VDBE 与 SQLite 的后端，特别是 B 树模块有大量的交互。一个 SQLite 数据库文件本质上是一组 B 树[23]。B 树要么是表 B 树，要么是索引 B 树。表 B 树总是使用 64 位有符号整数键，并在叶子节点中存储数据。索引 B 树使用任意键，并且根本不存储数据。数据库模式中的每个表都由一个表 B 树表示。表 B 树的键是表的隐式 rowid 列。对于 INTEGER PRIMARY KEY 表，主键列取代 rowid 成为 B 树键。用 WITHOUT ROWID 规范声明的表是一种特殊情况；这些表完全存储在索引 B 树中。对于 WITHOUT ROWID 表，B 树键由主键列和表的所有其余列组成。数据库模式中的每个索引都有一个索引 B 树，除非该索引已经由表 B 树表示，如 INTEGER PRIMARY KEY 表的情况。

页面缓存负责提供 B 树模块请求的数据页。页面缓存还负责确保修改后的页面安全有效地刷新到稳定存储中。最后，操作系统接口是底层文件系统的网关。SQLite 使用一个称为虚拟文件系统（VFS）的抽象对象来提供跨操作系统的可移植性。SQLite 为 Unix 和 Windows 操作系统提供了几个现有的 VFS。可以创建一个 VFS 来支持新的操作系统或扩展 SQLite 的功能。

## 事务

SQLite 是一个事务性数据库引擎。它提供原子性、一致性、隔离性和持久性的 ACID 保证。SQLite 有两种主要模式来实现这些保证：回滚模式和预写日志模式。

2.2.1 回滚模式。在回滚模式下，SQLite 通过获取数据库文件的共享锁来开始一个事务。在获取共享锁后，可以随意从数据库读取页面。如果事务涉及对数据库的更改，SQLite 将读锁升级为保留锁，这会阻止其他写入者但允许读者继续。在进行任何更改之前，SQLite 还会创建一个回滚日志文件。对于每个要修改的页面，SQLite 将其原始内容写入回滚日志，并将更新后的页面保留在用户空间中。当 SQLite 被指示提交事务时，它将回滚日志刷新到稳定存储。然后，SQLite 获取数据库文件的排他锁，这会阻止读者和写入者，并应用其更改。然后，更新后的数据库页面被刷新到稳定存储。然后，根据日志模式，通过几种机制之一使回滚日志无效。在 DELETE 模式下，SQLite 删除回滚日志。因为在某些系统上删除文件很昂贵，所以 SQLite 还提供了替代的日志模式。在 TRUNCATE 模式下，回滚日志被截断而不是删除。在 PERSIST 模式下，回滚日志的头部被零覆盖。使回滚日志无效的行为有效地提交了事务。最后，SQLite 释放数据库文件上的排他锁。

2.2.2 预写日志模式。从概念上讲，预写日志（WAL）模式是回滚模式的反转。在回滚模式中，SQLite 将原始页面写入回滚日志，并将修改后的页面写入数据库文件。相比之下，WAL 模式在数据库文件中保留原始页面，并将修改后的页面附加到单独的 WAL 文件中。在 WAL 模式下，SQLite 通过记录 WAL 中最后一个有效提交记录的位置（称为结束标记）来开始事务。当 SQLite 需要一个页面时，它会在 WAL 中搜索该页面在结束标记之前的最新版本。如果该页面不在 WAL 中，SQLite 会从数据库文件中检索该页面。更改仅附加到 WAL 的末尾。导致 WAL 增长超过指定大小的提交将触发检查点，此时 WAL 中的更新页面将被写回数据库文件。检查点后 WAL 文件不会被删除；相反，事务从开头开始覆盖该文件。

WAL 模式主要有两个优点。首先，WAL 模式提供了更高的并发性，因为在将更改提交到 WAL 时，读者可以继续在数据库上进行操作。虽然一次只能有一个写入者，但读者可以与一个写入者同时进行操作。其次，WAL 通常要快得多，因为它对稳定存储的写入次数更少，并且实际发生的写入更加顺序化。

然而，WAL 模式有显著的缺点。为了加速搜索 WAL，SQLite 在共享内存中创建一个 WAL 索引。这提高了读事务的性能，但共享内存的使用要求所有的读取者必须在同一台机器上。因此，WAL 模式在网络文件系统上不起作用。进入 WAL 模式后不可能改变页大小。此外，WAL 模式伴随着检查点操作的额外复杂性以及用于存储 WAL 和 WAL 索引的额外文件。

# 不断变化的工作负载和硬件

最初，SQLite 只是一个具有少量数据管理功能的小型库，但如今它已成为世界上使用最广泛的数据库引擎。然而，随着 SQLite 的使用不断增加，用户对它的要求也在不断提高。如今，SQLite 的现代用例已经发展出比简单数据存储平台所能满足的复杂得多的需求。许多应用程序因其作为独立于平台的存储格式的特性而使用 SQLite，而其他应用程序则更关注其健壮性和可靠性保证[35]。这些不断变化和增长的需求不仅反映了现代软件不断增加的复杂性，也反映了自 SQLite 诞生以来硬件的进步。在本节中，我们将研究硬件和工作负载的变化，以更好地了解 SQLite 在现代数据库引擎格局中的地位。

## 硬件进步

虽然随着时间的推移计算硬件的改进是众所周知的，但重要的是要结合背景理解其中一些变化发生得有多快。最早成功运行 SQLite 的设备之一是 Palm Pilot，这是一款由摩托罗拉 MC68328 驱动的个人数字助理，它是一个 16MHz 的单核处理器[40,45]。虽然在这种情况下是一个独立用户将 SQLite 部署到他们的个人手机上，但 SQLite 的趋势是在资源受限的环境中使用将继续。诺基亚和摩托罗拉是最早将 SQLite 应用于其手机的两家公司。最终，谷歌也会效仿，将 SQLite 集成到其安卓平台中，并且直到今天它仍在该平台上被使用。[27,36,45]。

然而，自 21 世纪初以来，移动计算已经发生了根本性的变化。例如，我们在第 4 节评估中使用的树莓派 4B 型于 2019 年 7 月发布，是一款价格低廉但功能强大的单板计算机[12,13]。树莓派 4B 型使用 ARM Cortex-A72，一款 1.5GHz 的四核处理器[14]，与上述摩托罗拉处理器相比，性能有了显著提升。此外，树莓派 4B 型由支持单指令多数据（SIMD）和硬件级并行性的计算硬件提供动力。正如摩托罗拉处理器和树莓派 4B 型之间的巨大差异所表明的那样，移动计算硬件的能力已经迅速增长。

## 工作负载的变化

除了上述硬件方面的进步之外，使用 SQLite 的软件也在不断发展。我们强调，从根本上说，SQLite 是一个专注于联机事务处理（OLTP）的数据库引擎，针对在资源受限环境中的使用进行了显著优化。然而，SQLite 经常被用于与它最初设计目的截然不同的工作负载。例如，对手机上 SQLite 使用情况进行的一个月跟踪观察到了各种不同的工作负载，包括不同的查询复杂性和读写混合比例[39]。很大一部分操作是简单的键值查找，这表明 SQLite 经常被简单地用作键值存储。然而，跟踪中还包括了复杂的联机分析处理（OLAP）查询的重要尾部。这些查询涉及多个层次的嵌套或五个或更多表之间的连接。此外，大约 25%的所有观察到的语句涉及对数据库的写入。其中许多写入是 UPSERT（插入或替换操作），进一步证明 SQLite 经常被用作键值存储。跟踪中还包括了很大比例的 DELETE 操作，这些操作比其他语句昂贵得多，平均每个语句约为 4 毫秒。一些 DELETE 语句包含带有嵌套 SELECT 查询的谓词。这项研究表明，SQLite 的使用极其多样化。此外，这项研究仅限于手机使用；当考虑 SQLite 运行的设备范围时，我们预计工作负载的多样性会更大。总的来说，我们发现这些观察结果代表了现实世界应用不断扩大的需求。

## SQLite 在现实世界的应用

随着时间的推移，计算硬件和应用软件的进步使 SQLite 处于独特的地位。虽然它仍然是世界上使用最广泛的数据库引擎，但硬件能力和软件需求的巨大变化使 SQLite 面临一系列独特的挑战。

硬件能力的扩展要求对 SQLite 的底层实现进行更深入的评估。值得注意的是，SQLite 通常不使用多个线程，这限制了它利用可用硬件并行性的能力。对于对大量数据进行排序，SQLite 使用一种可选的多线程外部归并排序算法。对于所有其他操作，SQLite 在调用线程中执行所有工作。这种设计最大限度地减少了与设备上运行的其他进程的资源竞争。然而，某些工作负载，特别是那些包含复杂联机分析处理（OLAP）的工作负载，很可能会从多线程中受益。此外，SQLite 的面向行的存储格式和执行引擎对于许多 OLAP 操作来说并不理想。一般来说，SQLite 被认为在与最先进的专注于 OLAP 的数据库引擎相比不具竞争力，特别是在其局限性的背景下。相比之下，DuckDB [47] 通过一系列模仿 SQLite 的功能，如可嵌入式设计、单文件数据库和自包含代码，将自己定位为“用于分析的 SQLite”。然而，DuckDB 将许多最先进的 OLAP 技术引入到类似 SQLite 的环境中，例如向量化引擎和并行查询处理。这些功能共同使 DuckDB 具有强大的 OLAP 性能。我们质疑哪些专注于 OLAP 的优化可以被纳入 SQLite 中，而不会牺牲其在不同工作负载下的可移植性、紧凑性、可靠性和效率。

# 评估

在本节中，我们对 SQLite 进行了广泛的性能评估。我们采用了三个基准测试，每个测试都模拟了不同类型的进程内数据管理，即在线事务处理（OLTP）、在线分析处理（OLAP）和二进制大对象（blob）I/O。虽然这些基准测试并未涵盖嵌入式数据库引擎的所有现有用例，但它们代表了最常见的工作负载。我们确定了 SQLite 在 OLAP 性能方面的关键瓶颈，讨论了潜在解决方案的权衡，并展示了我们的优化所带来的性能影响。最后，我们讨论了 SQLite 的“占用空间”：编译所需的内存和时间量、生成的二进制文件的大小以及存储基准数据集所需的空间。

我们使用 DuckDB [47] 作为比较的参考点。DuckDB 是一种针对分析进行优化的嵌入式数据库引擎。与 SQLite 的设计类似，DuckDB 完全由两个文件构建，一个头文件和一个实现文件，没有外部依赖项。DuckDB 嵌入在主机应用程序的进程中，并管理存储在单个文件中的数据库。然而，相比之下 DuckDB 与 SQLite 不同，它采用列式数据组织和向量化查询执行。DuckDB 还使用了一种针对批量操作优化的多版本并发控制变体。我们将 DuckDB 作为基线并非暗示一个系统绝对比另一个系统更好。相反，我们观察到有大量的任务在这些任务中使用 SQLite 或 DuckDB 都是合适的。我们对 DuckDB 和 SQLite 进行评估，以更全面地了解这两个系统的性能。

我们实验的细节如下。

・硬件。我们使用两种硬件配置：在 CloudLab [9] 上配置的云服务器，配备英特尔至强银牌 4114 CPU；以及搭载 ARM Cortex-A72 CPU 的树莓派 4 Model B [14]。更多详细信息见表 2。

版本。我们使用了 SQLite 3.38.0 版本和 DuckDB 0.3.2 版本。在撰写本文时，这些是当时最新的可用软件版本。

Options. SQLite 和 DuckDB 是使用 gcc -O3 构建的。SQLite 是使用除了 SQLITE_DEFAULT_WAL_SYNCHRONOUS 以外的所有推荐编译时选项 [22] 构建的，以在 WAL 模式下保持持久性。我们添加了选项 SQLITE_OMIT_LOAD_EXTENSION。DuckDB 被限制为单线程。除非另有说明，SQLite3 和 DuckDB 都被允许使用 1GB 的内存。所有其他选项保持默认。

报告。对于每个实验，我们绘制三次试验的平均结果。我们观察到三次试验之间的差异可以忽略不计。每个实验都标有四舍五入到一位有效数字的平均结果。由于性能上的极大差异，一些图使用对数刻度。
