# 算法

![|600](assets/Pasted%20image%2020230419005228.png)

## LRU

![|600](assets/Pasted%20image%2020230418223021.png)

# 原理

## TCP

[拔掉网线后，原本的 TCP 连接还存在吗？](https://www.cnblogs.com/xiaolincoding/p/15892375.html)

连接的建立：
首先 Client 会给 Server 发送一个 SYN 包，但是该 SYN 包可能会在传输过程中丢失，或者因为其他原因导致 Server 无法处理，此时 Client 这一侧就会触发超时重传机制。但是也不能一直重传下去，重传的次数也是有限制的，这就是 tcp_syn_retries 这个配置项来决定的。

![|600](assets/Pasted%20image%2020230419003224.png)

在 Client 发出 SYN 后，如果过了 1 秒，还没有收到 Se rver 的响应，那么就会进行第一次重传；如果经过 2s 的时间还没有收到 Server 的响应，就会进行第二次重传；一直重传 tcp_syn_retries 次。

![|600](assets/Pasted%20image%2020230419003231.png)
tcp_syn_retries 的默认值是 6，也就是说如果 SYN 一直发送失败，会在（1 + 2 + 4 + 8 + 16+ 32 + 64）秒，即 127 秒后产生 ETIMEOUT 的错误。

![|600](assets/Pasted%20image%2020230419003444.png)

![|600](assets/Pasted%20image%2020230419003454.png)
FIN_WAIT_2 状态，TCP 进入到这个状态后，如果本端迟迟收不到对端的 FIN 包，那就会一直处于这个状态，于是就会一直消耗系统资源。Linux 为了防止这种资源的开销，设置了这个状态的超时时间 tcp_fin_timeout，默认为 60s，超过这个时间后就会自动销毁该连接。
TIME_WAIT 状态存在的意义是：最后发送的这个 ACK 包可能会被丢弃掉或者有延迟，这样对端就会再次发送 FIN 包。如果不维持 TIME_WAIT 这个状态，那么再次收到对端的 FIN 包后，本端就会回一个 Reset 包，这可能会产生一些异常。

TCP KeepAlive 的原理？

### Bloom Filter

![|600](assets/Pasted%20image%2020230419004551.png)

### Skip table

![|600](assets/Pasted%20image%2020230419004757.png)

## MapReduce

![|600](assets/Pasted%20image%2020230419004332.png)

## Raft

![|600](assets/Pasted%20image%2020230418235028.png)
![|600](assets/Pasted%20image%2020230418235230.png)
如何避免脑裂？要有多数节点才能形成集群; 获得大多数选票；能投的票是一个定值。
![|600](assets/Pasted%20image%2020230419005004.png)

## ZooKeeper

- Session 机制
- 应用层心跳+TCP 的问题
- 如何利用 ZooKeeper 实现选举？如何避免惊群？

## 分布式事务

![](assets/Pasted%20image%2020230419003012.png)

    事务隔离级别

![](assets/Pasted%20image%2020230419011341.png)

## 操作系统

### vfs open 如何实现

![](assets/Pasted%20image%2020230419011603.png)

### PageCache

![](assets/Pasted%20image%2020230419002729.png)

### 预读

分为

- 启发式预读：存在命中率问题
- 通知式预读：`fadvise(2)`

启发式分为：

- mmap read-around
- read-ahead Linux 内置的预读算法

![](assets/Pasted%20image%2020230419004045.png)

# 语言

## 垃圾回收

Mark and sweep

- 问题：碎片整理、stop-the-world、环形引用
  stw > RedLock、Lease

## C++

### 什么是迭代器失效

![](assets/Pasted%20image%2020230418235755.png)
![](assets/Pasted%20image%2020230418235805.png)

### 什么是 RAII

![](assets/Pasted%20image%2020230418235937.png)

### 如何实现内存泄漏检查

![](assets/Pasted%20image%2020230419000302.png)

### 智能指针

![](assets/Pasted%20image%2020230419000558.png)

## Go

### 什么是 context

![](assets/Pasted%20image%2020230419001437.png)

### 如何实现 timeout

![](assets/Pasted%20image%2020230419001538.png)

## Java

### Wait Notify

![](assets/Pasted%20image%2020230419001553.png)

# 分布式锁

Client 感知到的锁过期时间一定要早于 Server 的感知。否则会造成双 leader 问题。
如何避免？

- Client 什么时候认为自己持有的锁已经失效？
- Server 什么时候认为之前发放的锁已经失效？

RedLock
![](assets/Pasted%20image%2020230419001839.png)
![](assets/Pasted%20image%2020230419001911.png)
![](assets/Pasted%20image%2020230419002441.png)

# 容器

![](assets/Pasted%20image%2020230418230754.png)

![](assets/Pasted%20image%2020230418230725.png)

# Kubernetes

## Service 如何实现？

# [[学习/秒杀系统]]

![](f7674689a81d4a05d2c363f4c5a4a9ee.jpg)
