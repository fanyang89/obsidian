![[assets/Pasted image 20220315112937.png]]

## 现象

17.61 升级失败的原因是集群升级预检查阶段会去检查 zk 集群 host 是否符合预期，符合预期的判定规则是解析 `/etc/zookeeper/zoo.cfg` 中的 dynamicConfigFile 指向的动态配置文件，然后将解析的结果与 mongo 中主节点信息做对比进行的判定。
上周（9 号）的时候 19.40 进行过正常的 storage -> master 操作，转换的日志在 17.65 节点的 `/var/log/zbs/cmd_zbs_cluster.INFO` 这里。
当前 19.40 节点的 zoo.cfg 指向的配置：zoo.cfg.dynamic.85000088da（未包含自身） 与其他 4 个zk 节点所使用的不一致（zoo.cfg.dynamic.8500008908) 同时发现 19.40 存在一个配置文件：zoo.cfg.dynamic.next 中的配置与其他节点是一致的，版本号也是一致的。

## 现在可以获得的情报

故障节点：19.40，存在一个 zoo.cfg.dynamic.next 文件。
故障时间：2022-03-09 17:40

```bash
-rwxr-xr-x 1 fanmi fanmi  314  3月  9 17:40 zoo.cfg.dynamic.next
```

reconfig 发生的时间点：
显然，zoo.cfg.dynamic.next 的存在，意味着这一次 reconfig 没有在这个节点上正确 commit。

## 行为分析

witness 日志：

```
2022-03-10 03:45:39,075 [myid:9] - INFO  [WorkerReceiver[myid=9]:FastLeaderElection@697] - Notification: 2 (message format version), -9223372036854775808 (n.leader), 0x0 (n.zxid), 0x1 (n.round), LOOKING (n.state), 11 (n.sid), 0x0 (n.peerEPoch), LOOKING (my state)85000088da (n.config version)
2022-03-10 03:45:39,076 [myid:9] - WARN  [QuorumPeer[myid=9](plain=3.3.3.2:2181)(secure=disabled):FastLeaderElection@1061] - Ignoring notification for non-cluster member sid -9223372036854775808 from sid 11
```

可以看到，收到了一个来自 sid=11 节点的 Notify，sid=11 认为 leader 是 -9223372036854775808。

```java
/**
 * Returns the initial vote value of server identifier.
 *
 * @return long
 */
private long getInitId(){
	if(self.getQuorumVerifier().getVotingMembers().containsKey(self.getId()))
		return self.getId();
	else return Long.MIN_VALUE;
}
```

很显然，这是因为 sid=11 在获取 init id 时，因为认为自己不在集群中，所以返回了 Long.MIN_VALUE。

目录中存在：

```bash
$ tree ./zkdata-1940-11/etc/zookeeper
./zkdata-1940-11/etc/zookeeper
├── configuration.xsl
├── log4j.properties
├── zoo.cfg
├── zoo.cfg.dynamic
├── zoo.cfg.dynamic.85000088da
├── zoo.cfg.dynamic.next
├── zoo_sample.cfg
└── zoo_zbs.cfg
```

```bash
$ tree ./zkdata-1765-7/etc/zookeeper
./zkdata-1765-7/etc/zookeeper
├── configuration.xsl
├── log4j.properties
├── zoo.cfg
├── zoo.cfg.dynamic
├── zoo.cfg.dynamic.85000088da # 没有 11
├── zoo.cfg.dynamic.8500008901 # 没有 11
├── zoo.cfg.dynamic.8500008905 # 没有 11
├── zoo.cfg.dynamic.8500008908 # 有 sid=11
├── zookeeper-env.sh
├── zoo_sample.cfg
└── zoo_zbs.cfg
```

## 如何获取 config 版本号

![[assets/Pasted image 20220317112816.png]]

## FLE

```java
// check if we have a version that includes config. If so extract config info from message.
if (version > 0x1) {
	int configLength = response.buffer.getInt();

	// we want to avoid errors caused by the allocation of a byte array with negative length
	// (causing NegativeArraySizeException) or huge length (causing e.g. OutOfMemoryError)
	if (configLength < 0 || configLength > capacity) {
		throw new IOException(String.format("Invalid configLength in notification message! sid=%d, capacity=%d, version=%d, configLength=%d",
							  response.sid, capacity, version, configLength));
	}

	byte b[] = new byte[configLength];

	response.buffer.get(b);

	synchronized (self) {
		try {
			rqv = self.configFromString(new String(b));
			QuorumVerifier curQV = self.getQuorumVerifier();
			if (rqv.getVersion() > curQV.getVersion()) {
				LOG.info("{} Received version: {} my version: {}", self.getId(),
						Long.toHexString(rqv.getVersion()),
						Long.toHexString(self.getQuorumVerifier().getVersion()));
				if (self.getPeerState() == ServerState.LOOKING) {
					LOG.debug("Invoking processReconfig(), state: {}", self.getServerState());
					self.processReconfig(rqv, null, null, false);
					if (!rqv.equals(curQV)) {
						LOG.info("restarting leader election");
						self.shuttingDownLE = true;
						self.getElectionAlg().shutdown();

						break;
					}
				} else {
					LOG.debug("Skip processReconfig(), state: {}", self.getServerState());
				}
			}
		} catch (IOException | ConfigException e) {
			LOG.error("Something went wrong while processing config received from {}. " +
					  "Continue to process the notification message without handling the configuration.", response.sid);
		}
	}
} else {
	LOG.info("Backward compatibility mode (before reconfig), server id: {}", response.sid);
}
```

19.40 日志：

```bash
2022-03-10 03:45:39,076 [myid:11] - INFO [WorkerReceiver[myid=11]:FastLeaderElection$Messenger$WorkerReceiver@299] - 11 Received version: 8500008908 my version: 85000088da
2022-03-10 03:45:39,076 [myid:11] - INFO [WorkerReceiver[myid=11]:FastLeaderElection@697] - Notification: 2 (message format version), 9 (n.leader), 0x850001d71c (n.zxid), 0x1 (n.round), LOOKING (n.state), 9 (n.sid), 0x85 (n.peerEPoch), FOLLOWING (my state)8500008908 (n.config version)
```

可以发现：

1. 2022-03-10 03:45:39 时，19.40 才收到 config 8500008908。
2. 由于当前状态是 FOLLOWING 不是 LOOKING，因此忽略了这个 config 8500008908。

问题：

1. 为什么 19.40 隔了这么久才收到 config

## 结论

四节点视图 ABCD，一节点视图 ABCDE
E 启动，进入 FOLLOWING
tuna 脚本进行 reconfig 成 ABCD（为了获取当前的 config）
E 被剔除

## 疑问

### 收到空的 reconfig 后，ZooKeeper 会做什么？
